<#@ template cleanws="true" #>
<# for struc in &self.structs {
    let ids: Vec<_>;
    if !struc.values.id.is_empty() {
        ids = struc.values.id
            .trim_left_matches('[').trim_right_matches(']')
            .split(' ')
            .filter(|s| !s.is_empty())
            .map(|s| self.get_property(s.trim()))
            .collect();
    } else {
        ids = Vec::new();
    }

    let props: Vec<_> = self.properties.iter().filter(|p|
        p.struct_name == struc.name && !ids.contains(&p)).collect();

    let nesteds: Vec<_> = self.nesteds.iter().filter(|p|
        p.struct_name == struc.name).collect();

    let all_props = ids.iter().chain(props.iter());

#>
<#= document(&struc.values.doc) #>
pub struct <#= struc.name #> {
<# for p in all_props {
    if !p.values.doc.is_empty() { #>
<#= indent(document(&p.values.doc), 1) #>
<# } #>
    <#= p.get_attr_name(&struc.name) #>: <#= p.type_s #>,
<# }

// Nested structs
for p in &nesteds {
    if !p.values.doc.is_empty() { #>
<#= indent(document(&p.values.doc), 1) #>
<# } #>
    <#= p.get_attr_name(&struc.name) #>: <#= p.type_s #>,
<# } #>
}

<#
    // Write getter for properties
    let all_props = ids.iter().chain(props.iter());
    let get_props: Vec<_> = all_props
        .filter(|p| p.values.get.unwrap()).collect();
    if !get_props.is_empty() {
#>
impl <#= struc.name #> {
<#      for p in get_props { #>
    pub fn get_<#= p.get_attr_name(&struc.name) #>(&self) -> <#= get_return_type(&p.type_s) #> {
    <# if p.type_s == "Option<String>" { #>
        self.<#= p.get_attr_name(&struc.name) #>.as_ref().map(|x| x.as_str())
    <# } else if p.type_s.starts_with("Option<") {
           if is_ref_type(&p.type_s[7..p.type_s.len() - 1]) { #>
        self.<#= p.get_attr_name(&struc.name) #>.as_ref()
        <# } else { #>
        self.<#= p.get_attr_name(&struc.name) #>
        <# }
       } else if is_ref_type(&p.type_s) { #>
        &self.<#= p.get_attr_name(&struc.name) #>
    <# } else { #>
        self.<#= p.get_attr_name(&struc.name) #>
    <# } #>
    }
<#      }

        // Nested structs
        for p in nesteds {#>
    pub fn get_<#= p.get_attr_name(&struc.name) #>(&self) -> <#= get_return_type(&p.type_s) #> {
    <# if p.type_s == "Option<String>" { #>
        self.<#= p.get_attr_name(&struc.name) #>.as_ref().map(|x| x.as_str())
    <# } else if p.type_s.starts_with("Option<") {
           if is_ref_type(&p.type_s[7..p.type_s.len() - 1]) { #>
        self.<#= p.get_attr_name(&struc.name) #>.as_ref()
        <# } else { #>
        self.<#= p.get_attr_name(&struc.name) #>
        <# }
       } else if is_ref_type(&p.type_s) { #>
        &self.<#= p.get_attr_name(&struc.name) #>
    <# } else { #>
        self.<#= p.get_attr_name(&struc.name) #>
    <# } #>
    }
<#        } #>
}

<#  } #>
<# } #>
