<#@ template cleanws="true" #>
impl Connection {
    fn handle_message_generated(&mut self, msg: &Notification) {
        // TODO Also raise events for changes, adds, removes
        // TODO We cannot be sure that the ideas that we get really exist, so
        // check if have the channel, etc. first.
        match *msg {
<# for event in &self.decls {
    let enum_name = &self.messages.notifies[&event.msg.notify_name].enum_name;
#>
            Notification::<#= enum_name #>(ref cmd) => {
            <# if event.op == RuleOp::Remove { #>
                self.cm.remove_<#= to_snake_case(&event.book_struct.name) #>(<#= get_id_args(event) #>);
            <# } else if event.op == RuleOp::Update { #>
                let mut r = self.cm.get_mut_<#= to_snake_case(&event.book_struct.name) #>(<#= get_id_args(event) #>);
                <# // Update the object
                for rule in &event.rules {
                    match *rule {
                        RuleKind::Map { from, to, op } => {
                            // Put field from packet into bookkeeping struct
                            match op {
                                RuleOp::Update => { #>
                r.<#= to_snake_case(&to.name) #> = cmd.<#= from.rust_name #>;
                                <# }
                                // The field in the struct is a vector
                                RuleOp::Add => { #>
                r.<#= to_snake_case(&to.name) #>.push(cmd.<#= from.rust_name #>);
                                <# }
                                RuleOp::Remove => { #>
                                    // Find index and remove
                let i = r.<#= to_snake_case(&to.name) #>.iter().position(cmd.<#= from.rust_name #>);
                r.<#= to_snake_case(&to.name) #>.remove(i);
                                <# }
                            }
                        }

                        RuleKind::Function { ref name, ref to } => { #>
                let (<#= join(to.iter().map(|p| get_prop_name(p)), ", ") #>) = self.<#= to_snake_case(name) #>(cmd, &mut *r);
            <# for p in to.iter() { #>
                r.<#= get_prop_name(p) #> = <#= get_prop_name(p) #>;
            <# }
                        }
                    }
                }
            } else if event.op == RuleOp::Add {
                // Create a new object
                // First, call all functions
                for fun in event.rules.iter().filter(|r| r.is_function()) {
                    if let RuleKind::Function { ref name, ref to } = *fun { #>
                let (<#= join(to.iter().map(|p| get_prop_name(p)), ", ") #>) = self.<#= to_snake_case(name) #>(cmd);
                    <# }
                } #>
                let r = <#= event.book_struct.name #> {
                <# let v = vec![];
                // Function return values
                for p in event.rules.iter()
                    .flat_map(|f| if let RuleKind::Function { ref to, .. } = *f {
                        to
                    } else {
                        &v
                    }) { #>
                    <#= get_prop_name(p) #>,
                <# }
                for p in event.rules.iter() {
                    if let RuleKind::Map { from, to, op } = *p {
                        if op != RuleOp::Update {
                            panic!("Cannot add or remove when adding a new struct");
                        } #>
                    <#= to_snake_case(&to.name) #>: cmd.<#= from.rust_name #>,
                    <# }
                } #>
                };
                self.cm.add_<#= to_snake_case(&event.book_struct.name) #>(<#= get_id_args(event) #>, r);
            <# } #>
            }
<# } #>
            _ => {} // Ignore unmentioned messages
        }
    }
}
