<#@ template cleanws="true" #>
<# for struc in &self.0.structs {
    let ids: Vec<_>;
    if !struc.values.id.is_empty() {
        ids = struc.values.id
            .trim_left_matches('[').trim_right_matches(']')
            .split(' ')
            .filter(|s| !s.is_empty())
            .map(|s| self.0.get_property(s.trim()))
            .collect();
    } else {
        ids = Vec::new();
    }

    let props: Vec<_> = self.0.properties.iter().filter(|p|
        p.struct_name == struc.name && !ids.contains(&p)).collect();

    //let nesteds: Vec<_> = self.0.nesteds.iter().filter(|p|
    //    p.struct_name == struc.name).collect();

#>
<#= doc_comment(&struc.values.doc) #>
pub struct <#= struc.name #><'a> {
    cm: &'a ConnectionManager,
<# for p in &ids { #>
    <#= p.get_attr_name(&struc.name) #>: <#= p.type_s #>,
<# } #>
}

<#= doc_comment(&struc.values.doc) #>
pub struct <#= struc.name #>Mut<'a> {
    cm: &'a mut ConnectionManager,
<# for p in &ids { #>
    <#= p.get_attr_name(&struc.name) #>: <#= p.type_s #>,
<# } #>
}
<#

fn create_id_getter(f: &mut ::std::fmt::Formatter, struc: &Struct, p: &Property)
    -> ::std::fmt::Result { #>
    pub fn get_<#= p.get_attr_name(&struc.name) #>(&self) -> <#= if p.type_s == "String" { String::from("&str") } else { get_return_type(&p.type_s) } #> {
    <# if p.type_s == "Option<String>" { #>
        self.<#= p.get_attr_name(&struc.name) #>.as_ref().map(|x| x.as_str())
    <# } else if p.type_s.starts_with("Option<") {
           if is_ref_type(&p.type_s[7..p.type_s.len() - 1]) { #>
        self.<#= p.get_attr_name(&struc.name) #>.as_ref()
        <# } else { #>
        self.<#= p.get_attr_name(&struc.name) #>
        <# }
       } else if is_ref_type(&p.type_s) { #>
        &self.<#= p.get_attr_name(&struc.name) #>
    <# } else { #>
        self.<#= p.get_attr_name(&struc.name) #>
    <# } #>
    }
<#
    Ok(())
}

fn create_normal_getter(f: &mut ::std::fmt::Formatter, struc: &Struct,
    p: &Property, ids: &[&Property]) -> ::std::fmt::Result { #>
    pub fn get_<#= p.get_attr_name(&struc.name) #>(&self) -> <#= get_return_type(&p.type_s) #> {
        let real = self.cm.get_<#= to_snake_case(&struc.name) #>(<#= get_id_args(ids, struc) #>);
    <# if p.type_s == "Option<String>" { #>
        if real.<#= p.get_attr_name(&struc.name) #>.is_some() {
            Some(Ref::map(real, |r| r.<#= p.get_attr_name(&struc.name) #>.as_ref().unwrap().as_str()))
        } else {
            None
        }
    <# } else if p.type_s.starts_with("Option<") {
           if is_ref_type(&p.type_s[7..p.type_s.len() - 1]) { #>
        if real.<#= p.get_attr_name(&struc.name) #>.is_some() {
            Some(Ref::map(real, |r| r.<#= p.get_attr_name(&struc.name) #>.as_ref().unwrap()))
        } else {
            None
        }
        <# } else { #>
        real.<#= p.get_attr_name(&struc.name) #>
        <# }
       } else if p.type_s == "String" { #>
        Ref::map(real, |r| r.<#= p.get_attr_name(&struc.name) #>.as_str())
    <# } else if p.type_s.starts_with("Vec<") { #>
        Ref::map(real, |r| r.<#= p.get_attr_name(&struc.name) #>.as_slice())
    <# } else if is_ref_type(&p.type_s) { #>
        Ref::map(real, |r| &r.<#= p.get_attr_name(&struc.name) #>)
    <# } else { #>
        real.<#= p.get_attr_name(&struc.name) #>
    <# } #>
    }
<#
    Ok(())
}

#>

impl<'a> <#= struc.name #><'a> {
<#
    // Ids
    for p in &ids {
        create_id_getter(f, struc, p)?;
    }

    // Normal properties
    // TODO Getters with an Id have to be generated by hand
    for p in props.iter().filter(|p| p.values.get.unwrap() && !p.type_s.ends_with("Id")) {
        create_normal_getter(f, struc, p, ids.as_slice())?;
    }
#>
}

impl<'a> <#= struc.name #>Mut<'a> {
<#
    // Ids
    for p in &ids {
        create_id_getter(f, struc, p)?;
    }

    // Normal properties
    // TODO Getters with an Id have to be generated by hand
    for p in props.iter().filter(|p| p.values.get.unwrap() && !p.type_s.ends_with("Id")) {
        create_normal_getter(f, struc, p, ids.as_slice())?;
    }
#>
}
<#
        // TODO Generating nested structs is not supported at the moment
        // Nested structs
        /*for p in nesteds {#>
    pub fn get_<#= p.get_attr_name(&struc.name) #>(&self) -> <#= get_return_type(&p.type_s) #> {
    <# if p.type_s == "Option<String>" { #>
        self.<#= p.get_attr_name(&struc.name) #>.as_ref().map(|x| x.as_str())
    <# } else if p.type_s.starts_with("Option<") {
           if is_ref_type(&p.type_s[7..p.type_s.len() - 1]) { #>
        self.<#= p.get_attr_name(&struc.name) #>.as_ref()
        <# } else { #>
        self.<#= p.get_attr_name(&struc.name) #>
        <# }
       } else if is_ref_type(&p.type_s) { #>
        &self.<#= p.get_attr_name(&struc.name) #>
    <# } else { #>
        self.<#= p.get_attr_name(&struc.name) #>
    <# } #>
    }
<#        }*/ #>

<# } #>
