<#@ template cleanws="true" #>
<# for struc in &self.0.structs {
	for prop in struc.properties.iter().filter(|p|
		// Nested struct
		!self.0.structs.iter().any(|s| s.name == p.type_s)
		&& !is_special_type(&p.type_s)) { #>
#[no_mangle]
pub extern "C" fn get_<#= to_snake_case(&struc.name) #>_<#= to_snake_case(&prop.name) #>(con_id: ConnectionId,
	<#= get_id_args(&self.0.structs, &struc) #>) -> <#= get_ffi_type(&prop.type_s) #> {
	// Get connection
	let con = if let Some(con) = CONNECTIONS.get(&con_id) {
		con.clone()
	} else {
		// TODO Somehow throw an exception in C#
		println!("FAILED TO GET PROPERTY <#= struc.name #>.<#= prop.name #>");
		<# if get_ffi_type(&prop.type_s) == "*mut c_char" { #>
		return std::ptr::null_mut();
		<# } else { #>
		return Default::default();
		<# } #>
	};
	let con = con.lock();
	let val = con.get_<#= to_snake_case(&struc.name) #>(<#= get_id_arg_names(&self.0.structs, &struc) #>);
	let val = &val.<#= to_snake_case(&prop.name) #><# if prop.opt { /* TODO */ #>.as_ref().unwrap()<# } #>;
	<# if prop.modifier.as_ref().map(|s| s == "array").unwrap_or(false) { /* TODO */ #>
	let val = &val[0];
	<# }

	#>
	<# // Convert to ffi type
	match prop.type_s.as_str() {
		// TODO Don't unwrap
		"str" => { #>
	CString::new(val.as_bytes()).unwrap().into_raw()
		<# }
		"Uid" => { #>
	CString::new(val.0.as_bytes()).unwrap().into_raw()
		<# }
		"ClientId" | "ClientDbId" | "ChannelId" | "ServerGroupId"
		| "ChannelGroupId" | "IconHash" => { #>
	val.0
		<# }
		// TODO With higher resulution than seconds?
		"DateTime" => { #>
	val.timestamp() as u64
		<# }
		// TODO With higher resulution than seconds?
		"Duration" => { #>
	val.num_seconds() as u64
		<# }
		// Enum
		"GroupType" | "GroupNamingMode" | "Codec" | "ChannelType" | "ClientType"
		| "HostMessageMode" | "CodecEncryptionMode" | "HostBannerMode"
		| "LicenseType" | "TextMessageTargetMode" => { #>
	val.to_u32().unwrap()
		<# }
		_ => { #>
	*<# if prop.opt { #>*<# } #>val
		<# }
	} #>
}

<# }
} #>
