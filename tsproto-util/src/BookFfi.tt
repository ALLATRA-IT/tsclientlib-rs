<#@ template cleanws="true" #>
<# for struc in &self.0.structs {
	// TODO Don't unwrap, throw exceptions
	for prop in struc.properties.iter().filter(|p|
		// Nested struct which is not a map
		(!self.0.structs.iter().any(|s| s.name == p.type_s)
			|| p.modifier.as_ref().map(|s| s == "map").unwrap_or(false))
		&& !is_special_type(&p.type_s)) {
		let id_args = get_id_args(&self.0.structs, &struc);
		let is_map = prop.modifier.as_ref().map(|s| s == "map").unwrap_or(false);
		let is_array = prop.modifier.as_ref().map(|s| s == "array").unwrap_or(false); #>
#[no_mangle]
pub extern "C" fn get_<#= to_snake_case(&struc.name) #>_<#= to_snake_case(&prop.name) #>(con_id: ConnectionId,
	<#= id_args #><#
		if is_array {
		#><# if !id_args.is_empty() { #>, <# } #>index: usize<#
		} else if is_map { #><# if !id_args.is_empty() { #>, <# } #>len: *mut usize<# } #>) -> <#=

		if is_map {
			// Return keys for map
			format!("*mut {}", get_ffi_type(prop.key.as_ref().unwrap()))
		} else {
			get_ffi_type(&prop.type_s)
		}

		#> {
	// Get connection
	let con = if let Some(con) = CONNECTIONS.get(&con_id) {
		con.clone()
	} else {
		// TODO Somehow throw an exception in C#
		println!("FAILED TO GET PROPERTY <#= struc.name #>.<#= prop.name #>");
		<# if get_ffi_type(&prop.type_s) == "*mut c_char" || is_map { #>
		return std::ptr::null_mut();
		<# } else { #>
		return Default::default();
		<# } #>
	};
	let con = con.lock();
	let val = con.get_<#= to_snake_case(&struc.name) #>(<#= get_id_arg_names(&self.0.structs, &struc) #>);
	let val = &val.<#= to_snake_case(&prop.name) #><# if prop.opt { /* TODO */ #>.as_ref().unwrap()<# } #>;
	<# if is_array { #>
	let val = val.get(index).unwrap();
	<# }

	if is_map { #>
	let mut val = val.keys().map(|v| v.0).collect::<Vec<_>>().into_boxed_slice();
	unsafe { *len = val.len(); }
	let res = val.as_mut_ptr();
	std::mem::forget(val);
	res
}
	<#
		continue;
	} #>
	<# // Convert to ffi type
	match prop.type_s.as_str() {
		"str" => { #>
	CString::new(val.as_bytes()).unwrap().into_raw()
		<# }
		"Uid" => { #>
	CString::new(val.0.as_bytes()).unwrap().into_raw()
		<# }
		"ClientId" | "ClientDbId" | "ChannelId" | "ServerGroupId"
		| "ChannelGroupId" | "IconHash" => { #>
	val.0
		<# }
		// TODO With higher resulution than seconds?
		"DateTime" => { #>
	val.timestamp() as u64
		<# }
		// TODO With higher resulution than seconds?
		"Duration" => { #>
	val.num_seconds() as u64
		<# }
		// Enum
		"GroupType" | "GroupNamingMode" | "Codec" | "ChannelType" | "ClientType"
		| "HostMessageMode" | "CodecEncryptionMode" | "HostBannerMode"
		| "LicenseType" | "TextMessageTargetMode" => { #>
	val.to_u32().unwrap()
		<# }
		_ => { #>
	*<# if prop.opt { #>*<# } #>val
		<# }
	} #>
}

<# if is_array { #>
pub extern "C" fn get_<#= to_snake_case(&struc.name) #>_<#= to_snake_case(&prop.name) #>_len(con_id: ConnectionId,
	<#= get_id_args(&self.0.structs, &struc) #>) -> usize {
	// Get connection
	let con = if let Some(con) = CONNECTIONS.get(&con_id) {
		con.clone()
	} else {
		// TODO Somehow throw an exception in C#
		println!("FAILED TO GET PROPERTY <#= struc.name #>.<#= prop.name #>");
		return Default::default();
	};
	let con = con.lock();
	let val = con.get_<#= to_snake_case(&struc.name) #>(<#= get_id_arg_names(&self.0.structs, &struc) #>);
	let val = &val.<#= to_snake_case(&prop.name) #><# if prop.opt { /* TODO */ #>.as_ref().unwrap()<# } #>;
	val.len()
}
<# } #>
<# }
} #>
