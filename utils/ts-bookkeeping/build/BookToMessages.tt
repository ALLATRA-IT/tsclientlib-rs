<#@ template cleanws="true" #>
<#
fn call_functions<'a, I: Iterator<Item=&'a RuleKind<'a>>>(
	_fmt: &mut fmt::Write,
	iter: I,
	prefix: &str,
) -> fmt::Result {
	for r in iter {
		match r {
			RuleKind::Function { name, to, .. } => {
				let mut to = to.iter().map(|t| t.get_rust_name()).collect::<Vec<_>>();
				let tos = if to.len() == 1 {
					to.remove(0)
				} else {
					format!("({})", to.as_slice().join(", "))
				};
				#>
		let <#= tos #> = <#= prefix #><#= to_snake_case(name) #>();
			<# }
			RuleKind::ArgumentFunction { from, name, to, .. } => {
				let mut to = to.iter().map(|t| t.get_rust_name()).collect::<Vec<_>>();
				let tos = if to.len() == 1 {
					to.remove(0)
				} else {
					format!("({})", to.as_slice().join(", "))
				};
				#>
		let <#= tos #> = <#= prefix #><#= to_snake_case(name) #>(<#= to_snake_case(from) #>);
			<# }
			_ => {}
		}
	}
	Ok(())
}

fn get_tos<'a>(e: &'a Event<'a>, r: Option<&'a RuleKind<'a>>) -> Vec<&'a Field> {
	let mut tos = Vec::new();
	for r in e.ids.iter().chain(r.iter().cloned()) {
		match r {
			RuleKind::Map { to, .. } |
			RuleKind::ArgumentMap { to, .. } => tos.push(*to),
			RuleKind::Function { to, .. } |
			RuleKind::ArgumentFunction { to, .. } =>
				tos.extend_from_slice(to.as_slice()),
		}
	}
	tos
}

fn get_all_arguments<'a>(e: &'a Event<'a>, r: Option<&'a RuleKind<'a>>) -> String {
	let mut args = String::new();
	for r in e.ids.iter().chain(r.iter().cloned()) {
		match r {
			RuleKind::ArgumentMap { .. } |
			RuleKind::ArgumentFunction { .. } => {
				let arg = get_arguments(r);
				if !arg.is_empty() {
					args.push_str(", ");
					args.push_str(&arg);
				}
			}
			_ => {}
		}
	}
	args
}

for e in &self.0.decls {
	// Update
	if e.op == RuleOp::Update { #>
impl<'a> <#= e.book_struct.name #>Mut<'a> {
<# for r in &e.rules { #>
	// TODO Return packet instead of future
	/*#[must_use = "futures do nothing unless polled"]
	pub fn set_<#= to_snake_case(r.from_name()) #>(&self<#=
		get_all_arguments(e, None) #>, <#= get_arguments(r) #>) -> impl Future<Item=(), Error=Error> + Send + 'static {
	<# call_functions(_fmt, e.ids.iter().chain(std::iter::once(r)), "self.inner.")?; #>
		self.connection.send_packet(messages::c2s::Out<#= e.msg.name #>Message::new(
			vec![messages::c2s::<#= e.msg.name #>Part {<# // Ids
		for r in &e.ids { #>
				<#= struct_assign(r, &e.msg, "self.inner.") #><#
		}

		// Dynamic data
		#>
				<#= struct_assign(r, &e.msg, "") #><#

		// Already assigned fields
		let tos = get_tos(e, Some(r));

		// All other fields
		for field in e.msg.attributes.iter().filter_map(|a| {
			let f = self.0.messages.get_field(a);
			if tos.contains(&f) { None } else { Some(f) }
		}) { #>
				<#= field.get_rust_name() #>: None,<# } #>
				phantom: PhantomData,
			}].into_iter()))
	}*/

<# } #>
}
<#
// Remove
} else if e.op == RuleOp::Remove {
	if e.rules.is_empty() {
		let args = get_all_arguments(e, None);
		let name_add = if !args.is_empty() {
			format!("_{}", &args[2..args.find(':').unwrap()])
		} else {
			"".into()
		}; #>
impl<'a> <#= e.book_struct.name #>Mut<'a> {
	// TODO Return packet instead of future
	/*#[must_use = "futures do nothing unless polled"]
	pub fn remove<#= name_add #>(&self<#= args #>) -> impl Future<Item=(), Error=Error> + Send + 'static {
	<# call_functions(_fmt, e.ids.iter(), "self.inner.")?; #>
		self.connection.send_packet(messages::c2s::Out<#= e.msg.name #>Message::new(
			vec![messages::c2s::<#= e.msg.name #>Part {<#
		// Ids
		for r in &e.ids { #>
				<#= struct_assign(r, &e.msg, "self.inner.") #><#
		}

		// All other fields
		let tos = get_tos(e, None);
		for field in e.msg.attributes.iter().filter_map(|a| {
			let f = self.0.messages.get_field(a);
			if tos.contains(&f) { None } else { Some(f) }
		}) { #>
				<#= field.get_rust_name() #>: None,<# } #>
				phantom: PhantomData,
			}].into_iter()))
	}*/
}
<# } else {
	// Remove the property
	for r in &e.rules {
		let name = r.from_name();
		let name = if name.ends_with('s') {
			&name[..name.len() - 1]
		} else { &name };
		let name = format!("{}{}", e.book_struct.name, name);

		let args = get_all_arguments(e, Some(r));
		// TODO The ServerGroup.remove(client) should be
		// ServerGroup.remove_client(client),
		// ServerGroup.remove() should remove the ServerGroup.

		let name_add = if !args.is_empty() {
			format!("_{}", &args[2..args.find(':').unwrap()])
		} else {
			"".into()
		}; #>

impl<'a> <#= name #>Mut<'a> {
	// TODO Return packet instead of future
	/*#[must_use = "futures do nothing unless polled"]
	pub fn remove<#= name_add #>(&self<#= args #>) -> impl Future<Item=(), Error=Error> + Send + 'static {
	<# call_functions(_fmt, e.ids.iter().chain(std::iter::once(r)), "self.")?; #>
		self.connection.send_packet(messages::c2s::Out<#= e.msg.name #>Message::new(
			vec![messages::c2s::<#= e.msg.name #>Part {<#
		// Ids
		for r in &e.ids { #>
				<#= struct_assign(r, &e.msg, "self.parent.") #><#
		}

		// Dynamic data
		#>
				<#= struct_assign(r, &e.msg, "") #><#

		// All other fields
		let tos = get_tos(e, Some(r));
		for field in e.msg.attributes.iter().filter_map(|a| {
			let f = self.0.messages.get_field(a);
			if tos.contains(&f) { None } else { Some(f) }
		}) { #>
				<#= field.get_rust_name() #>: None,<# } #>
				phantom: PhantomData,
			}].into_iter()))
	}*/
}
	<# }
	}
} else if e.op == RuleOp::Add {
	for r in &e.rules {
		let name = r.from_name();
		let name = if name.ends_with('s') {
			&name[..name.len() - 1]
		} else {
			name
		};
		#>

impl<'a> <#= e.book_struct.name #>Mut<'a> {
	// TODO Return packet instead of future
	/*#[must_use = "futures do nothing unless polled"]
	pub fn add_<#= to_snake_case(name) #>(&self
		<#= get_all_arguments(e, Some(r)) #>) -> impl Future<Item=(), Error=Error> + Send + 'static {
	<# call_functions(_fmt, e.ids.iter().chain(std::iter::once(r)), "self.")?; #>
		self.connection.send_packet(messages::c2s::Out<#= e.msg.name #>Message::new(
			vec![messages::c2s::<#= e.msg.name #>Part {<#
		// Ids
		for r in &e.ids { #>
				<#= struct_assign(r, &e.msg, "self.inner.") #><#
		}

		// Dynamic data
		#>
				<#= struct_assign(r, &e.msg, "") #><#

		// All other fields
		let tos = get_tos(e, Some(r));
		for field in e.msg.attributes.iter().filter_map(|a| {
			let f = self.0.messages.get_field(a);
			if tos.contains(&f) { None } else { Some(f) }
		}) { #>
				<#= field.get_rust_name() #>: None,<# } #>
				phantom: PhantomData,
			}].into_iter()))
	}*/
}
	<# }
} #>

<# } #>
