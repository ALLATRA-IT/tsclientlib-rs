<#@ template cleanws="true" #>
use std::marker::PhantomData;
use std::mem;

use chrono::naive::NaiveDateTime;
use chrono::{DateTime, Duration, Utc};
use num_traits::{FromPrimitive, ToPrimitive};
use tsproto::commands::Command;
use tsproto::packets::{Direction, InCommand, PacketType};

/*
Resulting code:
Static arguments which depend on 'cmd go into the rental struct, others into the normal struct.

Example for: sendmessage targetmode=1 target=2 static_arg_s=a\|b msg=bc|msg=a\|c
*/

pub trait InMessageTrait<'a> {
	fn new(cmd: &'a InCommand) -> Result<Self, ParseError> where Self: Sized;
}

#[derive(Debug)]
pub struct InMessage {
	cmd: InCommand,
	msg: InMessages<'static>,
}

#[derive(Debug)]
pub enum InMessages<'a> {
<# for msg_group in &self.0.msg_group {
	for msg in &msg_group.msg { #>
	<#= msg.name #>(In<#= msg.name #><'a>),
<# }
} #>
	Other,
}

impl InMessage {
	pub fn new(cmd: InCommand) -> Result<Self, ParseError> {
		let mut res = Self { cmd, msg: InMessages::Other };

		{
			// Parse message
			let msg: InMessages = loop { match res.cmd.data().name {
			<#
				let mut msgs: Vec<_> = self.0.msg_group.iter()
					.flat_map(|g| g.msg.iter())
					.filter(|m| m.notify.is_some())
					.collect();
				msgs.sort_unstable_by_key(|m| m.notify.as_ref().map(|s| s.as_str()).unwrap());
				for (notify, group) in &msgs.iter().group_by(|m| m.notify.as_ref().map(|s| s.as_str()).unwrap()) { #>
				"<#= notify #>" => {<#
					let group: Vec<_> = group.collect();
					let (msg, group) = group.split_last().unwrap();
					for msg in group { #>
					if let Ok(r) = In<#= msg.name #>::new(&res.cmd) {
						break InMessages::<#= msg.name #>(r);
					}<#
					} #> break InMessages::<#= msg.name #>(In<#= msg.name #>::new(&res.cmd)?); }
			<# } #>
				s => return Err(ParseError::UnknownCommand(s.to_string())),
			}};

			res.msg = unsafe { mem::transmute(msg) };
		}

		Ok(res)
	}

	#[inline]
	pub fn command(&self) -> &InCommand { &self.cmd }
	#[inline]
	pub fn msg(&self) -> &InMessages { &self.msg }
}

// Statics would look like this inside a struct:
// pub targetmode: TextMessageTargetMode,
// pub static_arg_s: &'a str,
<# for msg_group in &self.0.msg_group {
	for msg in &msg_group.msg { #>
#[derive(Debug)]
pub struct In<#= msg.name #><'a> {
<# if msg_group.default.response { #>
	pub return_code: Option<&'a str>,
<# } #>
	list: Vec<In<#= msg.name #>Part<'a>>,
}

#[derive(Debug)]
pub struct In<#= msg.name #>Part<'a> {
<# for a in &msg.attributes {
	let field = self.0.get_field(a); #>
	<# if field.get_rust_name() != field.ts { #>
	/// `<#= field.ts #>` in TeamSpeak.
	<# } #>
	pub <#= field.get_rust_name() #>: <#= field.get_rust_type(a, true).replace("&", "&'a ").replace("UidRef", "UidRef<'a>") #>,
<# }
	/// Use the lifetime and make this struct non-exhaustive.
#>
	phantom: PhantomData<&'a ()>,
}

impl<'a> InMessageTrait<'a> for In<#= msg.name #><'a> {
	fn new(cmd: &'a InCommand) -> Result<Self, ParseError> {
		let data = cmd.data();
		if data.name != "<#= msg.notify.as_ref().map(|s| s.as_str()).unwrap_or("") #>" {
			return Err(ParseError::WrongCommand(data.name.to_string()));
		}
		if <#= if msg_group.default.np { "!" } else { "" } #>cmd.newprotocol() {
			return Err(ParseError::WrongNewprotocol(cmd.newprotocol()));
		}
		if cmd.packet_type() != PacketType::Command<#= if msg_group.default.low { "Low" } else { "" } #> {
			return Err(ParseError::WrongPacketType(cmd.packet_type()));
		}
		<# if !msg_group.default.s2c { #>
		if cmd.direction() == Direction::S2C {
			return Err(ParseError::WrongDirection(cmd.direction()));
		}
		<# } #>
		<# if !msg_group.default.c2s { #>
		if cmd.direction() == Direction::C2S {
			return Err(ParseError::WrongDirection(cmd.direction()));
		}
		<# } #>
<# /*
		// Statics
		let it = cmd.iter();

		let arg = it.statics.get("targetmode")
			.ok_or_else(|| format_err!("Static argument targetmode not found in < #= msg.name # >"))?;
		let targetmode = TextMessageTargetMode::from_u32(arg.parse()?)
			.ok_or_else(|| format_err!("Invalid targetmode {} found in < #= msg.name # >", arg))?;
		let arg = it.statics.get("target");
		let target;
		if let Some(arg) = arg {
			target = Some(arg.parse()?);
		} else {
			target = None;
		}

		let static_arg_s = *it.statics.get("static_arg_s")
			.ok_or_else(|| format_err!("Static argument static_arg_s not found in < #= msg.name # >"))?;
*/ #>
	<# if msg_group.default.response { #>

		// Get return code
		let return_code = cmd.data().static_args.iter()
			.find(|(k, _)| *k == "return_code")
			.map(|(_, v)| v.as_ref());
	<# } #>

		// List arguments
		let mut list = Vec::new();
		for <#= if msg.attributes.is_empty() { "_" } else { "ccmd" } #> in cmd.iter() {
			list.push(In<#= msg.name #>Part {
		<# for a in &msg.attributes {
			let field = self.0.get_field(a); #>
				<#= field.get_rust_name() #>: {
				<# if !a.ends_with('?') { /* is not optional */ #>
					let val = ccmd.0.get("<#= field.ts #>")
						.ok_or(ParseError::ParameterNotFound { arg: "<#= field.pretty #>", name: "<#= msg.name #>", })?;
					<#= generate_deserializer(field) #>				},
				<# } else { #>
					if let Some(val) = ccmd.0.get("<#= field.ts #>") {
						Some({ <#= generate_deserializer(field) #> })
					} else { None } },
				<# } #>
		<# } #>
				phantom: PhantomData,
			});
		}
		// TODO Still missing: Warn if there are more arguments than we parsed

		Ok(In<#= msg.name #> {<# if msg_group.default.response { #> return_code,<# } #> list })
	}
}

<#
// Generated for static arguments
// #[inline]
// pub fn get_targetmode(&self) -> TextMessageTargetMode { self.targetmode }
// #[inline]
// pub fn get_target(&self) -> Option<u16> { self.target }
#>
impl<'a> In<#= msg.name #><'a> {
	#[inline]
	pub fn iter(&self) -> InMessageIterator<In<#= msg.name #>Part> { InMessageIterator(&self.list, 0) }
}

<# }
} #>

pub struct InMessageIterator<'a, T>(&'a [T], usize);
impl<'a, T> Iterator for InMessageIterator<'a, T> {
	type Item = &'a T;
	fn next(&mut self) -> Option<Self::Item> {
		let i = self.1;
		self.1 += 1;
		self.0.get(i)
	}
}

<#
fn generate_deserializer(field: &Field) -> String {
	let rust_type = field.get_rust_type("", true);
	if rust_type.starts_with("Vec<") {
		vector_value_deserializer(field)
	} else {
		single_value_deserializer(field, &rust_type)
	}
}

fn single_value_deserializer(field: &Field, rust_type: &str)
	-> String {
	let res = match rust_type {
		 "i8" |  "u8" |
		"i16" | "u16" |
		"i32" | "u32" |
		"i64" | "u64" => format!("val.parse().map_err(|e| ParseError::ParseInt {{
				arg: \"{}\",
				value: val.to_string(),
				error: e,
			}})?", field.pretty),
		"f32" | "f64" => format!("val.parse().map_err(|e| ParseError::ParseFloat {{
				arg: \"{}\",
				value: val.to_string(),
				error: e,
			}})?", field.pretty),
		"bool" => format!("match *val {{ \"0\" => false, \"1\" => true, _ => Err(ParseError::ParseBool {{
				arg: \"{}\",
				value: val.to_string(),
			}})? }}", field.pretty),
		"UidRef" => "UidRef(val)".into(),
		"&str" => "val".into(),
		"IconHash" => format!("IconHash(val.parse::<i64>().map_err(|e| ParseError::ParseInt {{
				arg: \"{}\",
				value: val.to_string(),
				error: e,
			}})? as u32)", field.pretty),
		"ClientId" |
		"ClientDbId" |
		"ChannelId" |
		"ServerGroupId" |
		"ChannelGroupId" => format!("{}(val.parse().map_err(|e| ParseError::ParseInt {{
				arg: \"{}\",
				value: val.to_string(),
				error: e,
			}})?)", rust_type, field.pretty),
		"TextMessageTargetMode" |
		"HostMessageMode" |
		"HostBannerMode" |
		"LicenseType" |
		"LogLevel" |
		"Codec" |
		"CodecEncryptionMode" |
		"Reason" |
		"ClientType" |
		"GroupNamingMode" |
		"GroupType" |
		"Permission" |
		"PermissionType" |
		"TokenType" |
		"PluginTargetMode" |
		"Error" => format!("{}::from_u32(val.parse().map_err(|e| ParseError::ParseInt {{
				arg: \"{}\",
				value: val.to_string(),
				error: e,
			}})?).ok_or(ParseError::InvalidValue {{
				arg: \"{1}\",
				value: val.to_string(),
				}})?", rust_type, field.pretty),
		"Duration" =>
			if field.type_s == "DurationSeconds" {
				format!("let val = val.parse::<i64>().map_err(|e| ParseError::ParseInt {{
					arg: \"{}\",
					value: val.to_string(),
					error: e,
				}})?;
				if let Some(_) = val.checked_mul(1000) {{ Duration::seconds(val) }}
				else {{ Err(ParseError::InvalidValue {{
					arg: \"{0}\",
					value: val.to_string(),
					}})? }}", field.pretty)
			} else if field.type_s == "DurationMilliseconds" {
				format!("Duration::milliseconds(val.parse::<i64>().map_err(|e| ParseError::ParseInt {{
					arg: \"{}\",
					value: val.to_string(),
					error: e,
				}})?)", field.pretty)
			} else {
				panic!("Unknown original time type {} found.", field.type_s);
			},
		"DateTime<Utc>" => format!("DateTime::<Utc>::from_utc(NaiveDateTime::from_timestamp_opt(val.parse().map_err(|e| ParseError::ParseInt {{
					arg: \"{}\",
					value: val.to_string(),
					error: e,
				}})?, 0).ok_or(ParseError::InvalidValue {{
					arg: \"{0}\",
					value: val.to_string(),
				}})?, Utc)", field.pretty),
		_ => panic!("Unknown type '{}'", rust_type),
	};
	indent(&res, 2)
}

fn vector_value_deserializer(field: &Field) -> String {
	let rust_type = field.get_rust_type("", true);
	let inner_type = &rust_type[4..rust_type.len()-1];
	String::from(format!("val.split(',').map(|val| Ok({})).collect::<Result<Vec<{}>, ParseError>>()?",
		single_value_deserializer(field, inner_type), inner_type))
}

fn generate_serializer(field: &Field, can_move: bool) -> String {
	let rust_type = field.get_rust_type("", false);
	if rust_type.starts_with("Vec<") {
		vector_value_serializer(field, can_move)
	} else {
		single_value_serializer(field, &rust_type, can_move)
	}
}

fn single_value_serializer(field: &Field, rust_type: &str, can_move: bool) -> String {
	match rust_type {
		 "i8" |  "u8" |
		"i16" | "u16" |
		"i32" | "u32" |
		"i64" | "u64" |
		"f32" | "f64" => "val.to_string()",
		"bool" => if can_move { "String::from(if  val { \"0\" } else { \"1\" })" }
						 else { "String::from(if *val { \"0\" } else { \"1\" })" },
		"String" => if can_move { "val" } else { "val.to_string()" },
		"Uid" => if can_move { "val.0" } else { "val.0.to_string()" },
		"ClientId" |
		"ClientDbId" |
		"ChannelId" |
		"ServerGroupId" |
		"ChannelGroupId" |
		"IconHash" => "val.0.to_string()",
		"TextMessageTargetMode" |
		"HostMessageMode" |
		"HostBannerMode" |
		"LicenseType" |
		"LogLevel" |
		"Codec" |
		"CodecEncryptionMode" |
		"Reason" |
		"ClientType" |
		"GroupNamingMode" |
		"GroupType" |
		"Permission" |
		"PermissionType" |
		"TokenType" |
		"PluginTargetMode" |
		"Error" => "val.to_u32().unwrap().to_string()",
		"Duration" =>
			if field.type_s == "DurationSeconds" {
				"val.num_seconds().to_string()"
			} else if field.type_s == "DurationMilliseconds" {
				"val.num_milliseconds().to_string()"
			} else {
				panic!("Unknown original time type {} found.", field.type_s);
			},
		"DateTime<Utc>" => "val.timestamp().to_string()",
		_ => panic!("Unknown type '{}'", rust_type),
	}.to_string()
}

fn vector_value_serializer(field: &Field, can_move: bool) -> String {
	let rust_type = field.get_rust_type("", false);
	let inner_type = &rust_type[4..rust_type.len()-1];
	// optimizations for special types
	match inner_type {
		"String" => String::from("let mut strb = String::new(); for val in val { if !strb.is_empty() { strb += \",\" } strb += &val; } strb"),
		_ => format!("let mut strb = String::new(); for val in val {{ if !strb.is_empty() {{ strb += \",\" }} let add = {}; strb += &add; }} strb", single_value_serializer(field, inner_type, can_move)),
	}
}

#>

<# for msg_group in &self.0.msg_group {
	let defs = &msg_group.default;
	for msg in &msg_group.msg { #>
#[derive(Debug, Clone)]
pub struct <#= msg.name #> {
<# if defs.response { #>
	pub return_code: Option<String>,
<# }

	// Attributes
	for a in &msg.attributes {
		let field = self.0.get_field(a);
#>
	pub <#= field.get_rust_name() #>: <#= field.get_rust_type(a, false) #>,
<# } #>
}
<#
	if defs.response {
#>

impl Response for <#= msg.name #> {
	fn get_return_code(&self) -> Option<&str> {
		self.return_code.as_ref().map(|s| s.as_str())
	}
	fn set_return_code(&mut self, return_code: Option<String>) {
		self.return_code = return_code;
	}
}
<# } #>

/*impl<'a> TryParse<&'a CanonicalCommand<'a>> for <#= msg.name #> {
	type Err = ParseError;
	fn try_from(<#= if msg.attributes.len() == 0 { "_" } else { "cmd" } #>: &'a CanonicalCommand<'a>) -> Result<Self, Self::Err> {
		Ok(<#= msg.name #> {
<#
	for a in &msg.attributes {
		let field = self.0.get_field(a);
#>
			<#= field.get_rust_name() #>: {
				<# if !a.ends_with('?') { /* is not optional */ #>
				let val = cmd.args.get("<#= field.ts #>")
					.ok_or(ParseError::ParameterNotFound {
						arg: "<#= field.pretty #>",
					})?;
					<#= generate_deserializer(field) #> },
				<# } else { #>
				if let Some(val) = cmd.args.get("<#= field.ts #>") {
					Some({ <#= generate_deserializer(field) #> })
				} else { None } },
				<# } #>
<# }
	if defs.response { #>
			return_code: cmd.args.get("return_code").map(|s| s.to_string()),
	<# } #>
		})
	}
}

impl<'a> Into<Command> for &'a <#= msg.name #> {
	fn into(self) -> Command {
		let<# if msg.attributes.iter().any(|a| a.ends_with('?')) { #> mut<# } #> args = vec![
<#
		for a in &msg.attributes {
			if a.ends_with('?') {
				continue;
			}
			let field = self.0.get_field(a); #>
			(String::from("<#= field.ts #>"), { let val = &self.<#= field.get_rust_name() #>; <#= generate_serializer(field, false) #> } ),
<# } #>
		];

<#
		// Add optional values
		for a in &msg.attributes {
			if !a.ends_with('?') {
				continue;
			}
			let field = self.0.get_field(a); #>
		if let Some(ref val) = self.<#= field.get_rust_name() #> {
			args.push((String::from("<#= field.ts #>"), { <#= generate_serializer(field, false) #> }));
		}
<# } #>

		Command {
			command: String::from("<#= msg.notify.as_ref().map(|s| s.as_str()).unwrap_or("") #>"),
			static_args: args,
			list_args: vec![],
		}
	}
}

impl Into<Command> for <#= msg.name #> {
	fn into(self) -> Command {
		let<# if msg.attributes.iter().any(|a| a.ends_with('?')) { #> mut<# } #> args = vec![
<#
		for a in &msg.attributes {
			if a.ends_with('?') {
				continue;
			}
			let field = self.0.get_field(a); #>
			(String::from("<#= field.ts #>"), { let val = self.<#= field.get_rust_name() #>; <#= generate_serializer(field, true) #> } ),
<# } #>
		];

<#
		// Add optional values
		for a in &msg.attributes {
			if !a.ends_with('?') {
				continue;
			}
			let field = self.0.get_field(a); #>
		if let Some(val) = self.<#= field.get_rust_name() #> {
			args.push((String::from("<#= field.ts #>"), { <#= generate_serializer(field, true) #> }));
		}
<# } #>

		Command {
			command: String::from("<#= msg.notify.as_ref().map(|s| s.as_str()).unwrap_or("") #>"),
			static_args: args,
			list_args: vec![],
		}
	}
}*/

<# }
}
// Create message types
#>
#[derive(Debug, Clone)]
pub enum Message {
<# for msg_group in &self.0.msg_group {
	for msg in &msg_group.msg { #>
	<#= msg.name #>(<#= msg.name #>),
<# }
} #>
}

/*impl Message {
	pub fn parse(cmd: CanonicalCommand) -> Result<Self, ParseError> {
		match cmd.command {
			<# for msg_group in &self.0.msg_group {
				for msg in msg_group.msg.iter().filter(|m| m.notify.is_some()) { #>
			"<#= msg.notify.as_ref().unwrap() #>" => Ok(Message::<#= msg.name #>(<#= msg.name #>::try_from(&cmd)?)),
			<# }
			} #>
			_ => Err(ParseError::UnknownCommand(cmd.command.to_string()))
		}
	}

	pub fn get_commandlow(&self) -> bool {
		match self {
			<# for msg_group in &self.0.msg_group {
				for msg in &msg_group.msg { #>
			Message::<#= msg.name #>(_) => <#= msg_group.default.low #>,
			<# }
			} #>
		}
	}

	pub fn get_newprotocol(&self) -> bool {
		match self {
			<# for msg_group in &self.0.msg_group {
				for msg in &msg_group.msg { #>
			Message::<#= msg.name #>(_) => <#= msg_group.default.np #>,
			<# }
			} #>
		}
	}
}

impl Into<Command> for Message {
	fn into(self) -> Command {
		match self {
			<# for msg_group in &self.0.msg_group {
				for msg in &msg_group.msg { #>
			Message::<#= msg.name #>(cmd) => cmd.into(),
			<# }
			} #>
		}
	}
}

impl<'a> Into<Command> for &'a Message {
	fn into(self) -> Command {
		match *self {
			<# for msg_group in &self.0.msg_group {
				for msg in &msg_group.msg { #>
			Message::<#= msg.name #>(ref cmd) => cmd.into(),
			<# }
			} #>
		}
	}
}*/
