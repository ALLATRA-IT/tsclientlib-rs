<#@ template cleanws="true" #>
use std::marker::PhantomData;
use std::mem;

use chrono::naive::NaiveDateTime;
use chrono::{DateTime, Duration, Utc};
use num_traits::{FromPrimitive, ToPrimitive};
use tsproto::commands::{Command, CanonicalCommand};
use tsproto::packets::{Direction, InCommand, PacketType};

type MyResult<T> = ::std::result::Result<T, ::failure::Error>;

/*
Resulting code:
Static arguments which depend on 'cmd go into the rental struct, others into the normal struct.

Example for: sendmessage targetmode=1 target=2 static_arg_s=a\|b msg=bc|msg=a\|c
*/

pub trait InMessageTrait<'a> {
	fn new(cmd: &'a InCommand) -> MyResult<Self> where Self: Sized;
	fn get_return_code(&self) -> Option<&str> { panic!("TODO") }
}

#[derive(Debug)]
pub struct InMessage {
	cmd: InCommand,
	msg: InMessages<'static>,
	return_code: Option<&'static str>,
}

#[derive(Debug)]
pub enum InMessages<'a> {
<# for msg_group in &self.0.msg_group {
	for msg in &msg_group.msg { #>
	<#= msg.name #>(In<#= msg.name #><'a>),
<# }
} #>
	Other,
}

impl InMessage {
	pub fn new(cmd: InCommand) -> MyResult<Self> {
		let mut res = Self { cmd, msg: InMessages::Other, return_code: None };

		{
			// Parse message
			let msg: InMessages;
			match res.cmd.data().name {
			<# for msg_group in &self.0.msg_group {
				let mut msgs: Vec<_> = msg_group.msg.iter().filter(|m| m.notify.is_some()).collect();
				msgs.sort_by_key(|m| m.notify.as_ref().map(|s| s.as_str()).unwrap());
				for (notify, group) in &msgs.iter().group_by(|m| m.notify.as_ref().map(|s| s.as_str()).unwrap()) { #>
				"<#= notify #>" => {
					<#
					let mut first = true;
					for msg in group { #>
					<#= if first { first = false; "" } else { "} else " } #>if let Ok(r) = In<#= msg.name #>::new(&res.cmd) {
						msg = InMessages::<#= msg.name #>(r);
					<# } #>
					} else {
						return Err(format_err!("Cannot parse command <#= notify #>").into());
					}
				}
			<# }
			} #>
				s => return Err(format_err!("Unknown command {}", s).into()),
			}

			res.msg = unsafe { mem::transmute(msg) };
			// Get return code
			let ret: Option<&str> = res.cmd.data().static_args.iter()
				.find(|(k, _)| *k == "return_code")
				.map(|(_, v)| v.as_ref());
			res.return_code = unsafe { mem::transmute(ret) };
		}

		Ok(res)
	}

	#[inline]
	pub fn command(&self) -> &InCommand { &self.cmd }
	#[inline]
	pub fn msg(&self) -> &InMessages { &self.msg }
	#[inline]
	pub fn return_code(&self) -> Option<&str> { self.return_code }
}

<# for msg_group in &self.0.msg_group {
	for msg in &msg_group.msg { #>
#[derive(Debug)]
pub struct In<#= msg.name #><'a> {
	pub targetmode: TextMessageTargetMode,
	pub target: Option<u16>,
	pub static_arg_s: &'a str,

	list: Vec<In<#= msg.name #>Part<'a>>,
}

#[derive(Debug)]
pub struct In<#= msg.name #>Part<'a> {
	pub msg: &'a str,
	/// Use the lifetime and make this struct non-exhaustive.
	phantom: PhantomData<&'a ()>,
}

impl<'a> InMessageTrait<'a> for In<#= msg.name #><'a> {
	fn new(cmd: &'a InCommand) -> MyResult<Self> {
		let data = cmd.data();
		if data.name != "<#= msg.notify.as_ref().map(|s| s.as_str()).unwrap_or("") #>" {
			return Err(format_err!("Not a <#= msg.name #> command"));
		}
		if <#= if msg_group.default.np { "!" } else { "" } #>cmd.newprotocol() {
			return Err(format_err!("Wrong newprotocol flag for <#= msg.name #> command"));
		}

		if cmd.packet_type() != PacketType::Command<#= if msg_group.default.low { "Low" } else { "" } #> {
			return Err(format_err!("Wrong packet type for <#= msg.name #> command").into());
		}

		<# if !msg_group.default.s2c { #>
		if cmd.direction() == Direction::S2C {
			return Err(format_err!("<#= msg.name #> is no s2c command").into());
		}
		<# } #>
		<# if !msg_group.default.c2s { #>
		if cmd.direction() == Direction::C2S {
			return Err(format_err!("<#= msg.name #> is no c2s command").into());
		}
		<# } #>

		// Statics
		let it = cmd.iter();

		let arg = it.statics.get("targetmode")
			.ok_or_else(|| format_err!("Static argument targetmode not found in <#= msg.name #>"))?;
		let targetmode = TextMessageTargetMode::from_u32(arg.parse()?)
			.ok_or_else(|| format_err!("Invalid targetmode {} found in <#= msg.name #>", arg))?;
		let arg = it.statics.get("target");
		let target;
		if let Some(arg) = arg {
			target = Some(arg.parse()?);
		} else {
			target = None;
		}

		let static_arg_s = *it.statics.get("static_arg_s")
			.ok_or_else(|| format_err!("Static argument static_arg_s not found in <#= msg.name #>"))?;

		// List arguments
		let mut list = Vec::new();
		for ccmd in cmd.iter() {
			let msg = ccmd.0.get("msg")
				.ok_or_else(|| format_err!("List argument msg not found in <#= msg.name #>"))?;
			list.push(In<#= msg.name #>Part { msg, phantom: PhantomData });
		}
		// TODO Still missing: Warn if there are more arguments than we parsed

		Ok(In<#= msg.name #> { targetmode, target, static_arg_s, list })
	}
}

impl<'a> In<#= msg.name #><'a> {
	#[inline]
	pub fn get_targetmode(&self) -> TextMessageTargetMode { self.targetmode }
	#[inline]
	pub fn get_target(&self) -> Option<u16> { self.target }

	//#[inline]
	//pub fn iter(&self) -> In<#= msg.name #>Iterator { In<#= msg.name #>Iterator(self, 0) }
}

impl<'a> In<#= msg.name #>Part<'a> {
	#[inline]
	pub fn get_msg(&self) -> &'a str { self.msg }
}

// TODO Make generic
/*pub struct In<#= msg.name #>Iterator<'a>(&'a In<#= msg.name #>, usize);
impl<'a> Iterator for In<#= msg.name #>Iterator<'a> {
	type Item = In<#= msg.name #>Part<'a>;
	fn next(&mut self) -> Option<Self::Item> {
		let i = self.1;
		self.1 += 1;
		self.0.rent_ref(|l| l.get(i))
	}
}*/

<# }
} #>

<#
fn generate_deserializer(field: &Field) -> String {
	let rust_type = field.get_rust_type("");
	if rust_type.starts_with("Vec<") {
		vector_value_deserializer(field)
	} else {
		single_value_deserializer(field, &rust_type)
	}
}

fn single_value_deserializer(field: &Field, rust_type: &str)
	-> String {
	match rust_type {
		 "i8" |  "u8" |
		"i16" | "u16" |
		"i32" | "u32" |
		"i64" | "u64" => format!("val.parse().map_err(|e| ParseError::ParseInt {{
				arg: \"{}\",
				value: val.to_string(),
				error: e,
			}})?", field.pretty),
		"f32" | "f64" => format!("val.parse().map_err(|e| ParseError::ParseFloat {{
				arg: \"{}\",
				value: val.to_string(),
				error: e,
			}})?", field.pretty),
		"bool" => format!("match *val {{ \"0\" => false, \"1\" => true, _ => Err(ParseError::ParseBool {{
				arg: \"{}\",
				value: val.to_string(),
			}})? }}", field.pretty),
		"Uid" => "Uid(val.to_string())".into(),
		"String" => "val.to_string()".into(),
		"IconHash" => format!("IconHash(val.parse::<i64>().map_err(|e| ParseError::ParseInt {{
				arg: \"{}\",
				value: val.to_string(),
				error: e,
			}})? as u32)", field.pretty),
		"ClientId" |
		"ClientDbId" |
		"ChannelId" |
		"ServerGroupId" |
		"ChannelGroupId" => format!("{}(val.parse().map_err(|e| ParseError::ParseInt {{
				arg: \"{}\",
				value: val.to_string(),
				error: e,
			}})?)", rust_type, field.pretty),
		"TextMessageTargetMode" |
		"HostMessageMode" |
		"HostBannerMode" |
		"LicenseType" |
		"LogLevel" |
		"Codec" |
		"CodecEncryptionMode" |
		"Reason" |
		"ClientType" |
		"GroupNamingMode" |
		"GroupType" |
		"Permission" |
		"PermissionType" |
		"TokenType" |
		"PluginTargetMode" |
		"Error" => format!("{}::from_u32(val.parse().map_err(|e| ParseError::ParseInt {{
				arg: \"{}\",
				value: val.to_string(),
				error: e,
			}})?).ok_or(ParseError::InvalidValue {{
				arg: \"{1}\",
				value: val.to_string(),
				}})?", rust_type, field.pretty),
		"Duration" =>
			if field.type_s == "DurationSeconds" {
				format!("let val = val.parse::<i64>().map_err(|e| ParseError::ParseInt {{
					arg: \"{}\",
					value: val.to_string(),
					error: e,
				}})?;
				if let Some(_) = val.checked_mul(1000) {{ Duration::seconds(val) }}
				else {{ Err(ParseError::InvalidValue {{
					arg: \"{0}\",
					value: val.to_string(),
					}})? }}", field.pretty)
			} else if field.type_s == "DurationMilliseconds" {
				format!("Duration::milliseconds(val.parse::<i64>().map_err(|e| ParseError::ParseInt {{
					arg: \"{}\",
					value: val.to_string(),
					error: e,
				}})?)", field.pretty)
			} else {
				panic!("Unknown original time type {} found.", field.type_s);
			},
		"DateTime<Utc>" => format!("DateTime::<Utc>::from_utc(NaiveDateTime::from_timestamp_opt(val.parse().map_err(|e| ParseError::ParseInt {{
					arg: \"{}\",
					value: val.to_string(),
					error: e,
				}})?, 0).ok_or(ParseError::InvalidValue {{
					arg: \"{0}\",
					value: val.to_string(),
				}})?, Utc)", field.pretty),
		_ => panic!("Unknown type '{}'", rust_type),
	}
}

fn vector_value_deserializer(field: &Field) -> String {
	let rust_type = field.get_rust_type("");
	let inner_type = &rust_type[4..rust_type.len()-1];
	String::from(format!("val.split(',').map(|val|Ok({})).collect::<Result<Vec<{}>, ParseError>>()?",
		single_value_deserializer(field, inner_type), inner_type))
}

fn generate_serializer(field: &Field, can_move: bool) -> String {
	let rust_type = field.get_rust_type("");
	if rust_type.starts_with("Vec<") {
		vector_value_serializer(field, can_move)
	} else {
		single_value_serializer(field, &rust_type, can_move)
	}
}

fn single_value_serializer(field: &Field, rust_type: &str, can_move: bool) -> String {
	match rust_type {
		 "i8" |  "u8" |
		"i16" | "u16" |
		"i32" | "u32" |
		"i64" | "u64" |
		"f32" | "f64" => "val.to_string()",
		"bool" => if can_move { "String::from(if  val { \"0\" } else { \"1\" })" }
						 else { "String::from(if *val { \"0\" } else { \"1\" })" },
		"String" => if can_move { "val" } else { "val.to_string()" },
		"Uid" => if can_move { "val.0" } else { "val.0.to_string()" },
		"ClientId" |
		"ClientDbId" |
		"ChannelId" |
		"ServerGroupId" |
		"ChannelGroupId" |
		"IconHash" => "val.0.to_string()",
		"TextMessageTargetMode" |
		"HostMessageMode" |
		"HostBannerMode" |
		"LicenseType" |
		"LogLevel" |
		"Codec" |
		"CodecEncryptionMode" |
		"Reason" |
		"ClientType" |
		"GroupNamingMode" |
		"GroupType" |
		"Permission" |
		"PermissionType" |
		"TokenType" |
		"PluginTargetMode" |
		"Error" => "val.to_u32().unwrap().to_string()",
		"Duration" =>
			if field.type_s == "DurationSeconds" {
				"val.num_seconds().to_string()"
			} else if field.type_s == "DurationMilliseconds" {
				"val.num_milliseconds().to_string()"
			} else {
				panic!("Unknown original time type {} found.", field.type_s);
			},
		"DateTime<Utc>" => "val.timestamp().to_string()",
		_ => panic!("Unknown type '{}'", rust_type),
	}.to_string()
}

fn vector_value_serializer(field: &Field, can_move: bool) -> String {
	let rust_type = field.get_rust_type("");
	let inner_type = &rust_type[4..rust_type.len()-1];
	// optimizations for special types
	match inner_type {
		"String" => String::from("let mut strb = String::new(); for val in val { if !strb.is_empty() { strb += \",\" } strb += &val; } strb"),
		_ => format!("let mut strb = String::new(); for val in val {{ if !strb.is_empty() {{ strb += \",\" }} let add = {}; strb += &add; }} strb", single_value_serializer(field, inner_type, can_move)),
	}
}

#>

<# for msg_group in &self.0.msg_group {
	let defs = &msg_group.default;
	for msg in &msg_group.msg { #>
#[derive(Debug, Clone)]
pub struct <#= msg.name #> {
<# if defs.response { #>
	pub return_code: Option<String>,
<# }

	// Attributes
	for a in &msg.attributes {
		let field = self.0.get_field(a);
#>
	pub <#= field.get_rust_name() #>: <#= field.get_rust_type(a) #>,
<# } #>
}
<#
	if defs.response {
#>

impl Response for <#= msg.name #> {
	fn get_return_code(&self) -> Option<&str> {
		self.return_code.as_ref().map(|s| s.as_str())
	}
	fn set_return_code(&mut self, return_code: Option<String>) {
		self.return_code = return_code;
	}
}
<# } #>

/*impl<'a> TryParse<&'a CanonicalCommand<'a>> for <#= msg.name #> {
	type Err = ParseError;
	fn try_from(<#= if msg.attributes.len() == 0 { "_" } else { "cmd" } #>: &'a CanonicalCommand<'a>) -> Result<Self, Self::Err> {
		Ok(<#= msg.name #> {
<#
	for a in &msg.attributes {
		let field = self.0.get_field(a);
#>
			<#= field.get_rust_name() #>: {
				<# if !a.ends_with('?') { /* is not optional */ #>
				let val = cmd.args.get("<#= field.ts #>")
					.ok_or(ParseError::ParameterNotFound {
						arg: "<#= field.pretty #>",
					})?;
					<#= generate_deserializer(field) #> },
				<# } else { #>
				if let Some(val) = cmd.args.get("<#= field.ts #>") {
					Some({ <#= generate_deserializer(field) #> })
				} else { None } },
				<# } #>
<# }
	if defs.response { #>
			return_code: cmd.args.get("return_code").map(|s| s.to_string()),
	<# } #>
		})
	}
}

impl<'a> Into<Command> for &'a <#= msg.name #> {
	fn into(self) -> Command {
		let<# if msg.attributes.iter().any(|a| a.ends_with('?')) { #> mut<# } #> args = vec![
<#
		for a in &msg.attributes {
			if a.ends_with('?') {
				continue;
			}
			let field = self.0.get_field(a); #>
			(String::from("<#= field.ts #>"), { let val = &self.<#= field.get_rust_name() #>; <#= generate_serializer(field, false) #> } ),
<# } #>
		];

<#
		// Add optional values
		for a in &msg.attributes {
			if !a.ends_with('?') {
				continue;
			}
			let field = self.0.get_field(a); #>
		if let Some(ref val) = self.<#= field.get_rust_name() #> {
			args.push((String::from("<#= field.ts #>"), { <#= generate_serializer(field, false) #> }));
		}
<# } #>

		Command {
			command: String::from("<#= msg.notify.as_ref().map(|s| s.as_str()).unwrap_or("") #>"),
			static_args: args,
			list_args: vec![],
		}
	}
}

impl Into<Command> for <#= msg.name #> {
	fn into(self) -> Command {
		let<# if msg.attributes.iter().any(|a| a.ends_with('?')) { #> mut<# } #> args = vec![
<#
		for a in &msg.attributes {
			if a.ends_with('?') {
				continue;
			}
			let field = self.0.get_field(a); #>
			(String::from("<#= field.ts #>"), { let val = self.<#= field.get_rust_name() #>; <#= generate_serializer(field, true) #> } ),
<# } #>
		];

<#
		// Add optional values
		for a in &msg.attributes {
			if !a.ends_with('?') {
				continue;
			}
			let field = self.0.get_field(a); #>
		if let Some(val) = self.<#= field.get_rust_name() #> {
			args.push((String::from("<#= field.ts #>"), { <#= generate_serializer(field, true) #> }));
		}
<# } #>

		Command {
			command: String::from("<#= msg.notify.as_ref().map(|s| s.as_str()).unwrap_or("") #>"),
			static_args: args,
			list_args: vec![],
		}
	}
}*/

<# }
}
// Create message types
#>
#[derive(Debug, Clone)]
pub enum Message {
<# for msg_group in &self.0.msg_group {
	for msg in &msg_group.msg { #>
	<#= msg.name #>(<#= msg.name #>),
<# }
} #>
}

/*impl Message {
	pub fn parse(cmd: CanonicalCommand) -> Result<Self, ParseError> {
		match cmd.command {
			<# for msg_group in &self.0.msg_group {
				for msg in msg_group.msg.iter().filter(|m| m.notify.is_some()) { #>
			"<#= msg.notify.as_ref().unwrap() #>" => Ok(Message::<#= msg.name #>(<#= msg.name #>::try_from(&cmd)?)),
			<# }
			} #>
			_ => Err(ParseError::UnknownCommand(cmd.command.to_string()))
		}
	}

	pub fn get_commandlow(&self) -> bool {
		match self {
			<# for msg_group in &self.0.msg_group {
				for msg in &msg_group.msg { #>
			Message::<#= msg.name #>(_) => <#= msg_group.default.low #>,
			<# }
			} #>
		}
	}

	pub fn get_newprotocol(&self) -> bool {
		match self {
			<# for msg_group in &self.0.msg_group {
				for msg in &msg_group.msg { #>
			Message::<#= msg.name #>(_) => <#= msg_group.default.np #>,
			<# }
			} #>
		}
	}
}

impl Into<Command> for Message {
	fn into(self) -> Command {
		match self {
			<# for msg_group in &self.0.msg_group {
				for msg in &msg_group.msg { #>
			Message::<#= msg.name #>(cmd) => cmd.into(),
			<# }
			} #>
		}
	}
}

impl<'a> Into<Command> for &'a Message {
	fn into(self) -> Command {
		match *self {
			<# for msg_group in &self.0.msg_group {
				for msg in &msg_group.msg { #>
			Message::<#= msg.name #>(ref cmd) => cmd.into(),
			<# }
			} #>
		}
	}
}*/
